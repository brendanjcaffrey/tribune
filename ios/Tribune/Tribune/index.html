<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <script src="/jszip.min.js"></script>
    <script src="/epubjs.min.js"></script>
    <style>
      /* this is a bit hacky, but prevents a flash of white on page load in dark mode */
      html,
      body {
        margin: 0;
        padding: 0;
        background-color: #fff;
        color: #000;
      }

      @media (prefers-color-scheme: dark) {
        html,
        body {
          background-color: #000;
          color: #fff;
        }
      }
    </style>
  </head>
  <body style="margin: 0">
    <div id="container">
      <div id="viewer"></div>
      <div
        id="footer"
        style="
          display: flex;
          justify-content: space-between;
          align-items: center;
          box-sizing: border-box;
          padding: 0 12px;
        "
      >
        <span
          id="progress"
          style="font-family: Roboto, Helvetica, Arial, sans-serif"
        >
        </span>
        <button
          id="dismiss"
          style="border: none; background-color: transparent; font-size: 20px"
          onclick="dismiss()"
        >
          X
        </button>
      </div>
    </div>
    <script>
      const footerHeight = 20;
      const footerRight = 12;
      const lightBackgroundColor = "#ffffff";
      const lightForegroundColor = "rgba(0, 0, 0, 0.87)";
      const lightLinkColor = "#1976d2";
      const darkBackgroundColor = "#000000";
      const darkForegroundColor = "#ffffff";
      const darkLinkColor = "#90caf9";
      let rendition;

      async function readLocalFileToArrayBuffer(url) {
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`Fetch failed: ${res.status}`);
        }
        return await res.arrayBuffer();
      }

      function dismiss() {
        window.webkit.messageHandlers.readerEvent.postMessage({
          type: "dismiss",
        });
      }

      function setPercentage(percentage) {
        document.getElementById("progress").innerText = `${percentage}%`;
      }

      function getStyles(backgroundColor, foregroundColor, linkColor) {
        return {
          body: {
            background: `${backgroundColor} !important`,
            color: `${foregroundColor} !important`,
            "font-family":
              '"Roboto", "Helvetica", "Arial", sans-serif !important',
            "font-size": "1rem !important",
            "line-height": "1.5 !important",
            margin: "16px !important",
            padding: "8px !important",
          },
          h1: {
            "font-family":
              '"Roboto", "Helvetica", "Arial", sans-serif !important',
            "font-size": "3rem !important",
            "font-weight": "400 !important",
            "line-height": "1.167 !important",
          },
          h2: {
            "font-family":
              '"Roboto", "Helvetica", "Arial", sans-serif !important',
            "font-size": "2.125rem !important",
            "font-weight": "400 !important",
            "line-height": "1.235 !important",
          },
          h3: {
            "font-family":
              '"Roboto", "Helvetica", "Arial", sans-serif !important',
            "font-size": "1.5rem !important",
            "font-weight": "400 !important",
            "line-height": "1.334 !important",
          },
          a: {
            color: `${linkColor} !important`,
            "text-decoration": "none",
          },
          p: {
            "margin-bottom": "16px",
          },
        };
      }

      function getLightStyles() {
        return getStyles(
          lightBackgroundColor,
          lightForegroundColor,
          lightLinkColor,
        );
      }

      function getDarkStyles() {
        return getStyles(
          darkBackgroundColor,
          darkForegroundColor,
          darkLinkColor,
        );
      }

      // Called from Swift
      async function openBook(path, initialProgress) {
        try {
          const buf = await readLocalFileToArrayBuffer(path);
          const book = ePub(buf);
          book.ready.then(() => {
            return book.locations.generate(150);
          });

          const windowHeight = window.innerHeight;
          const windowWidth = window.innerWidth;
          const container = document.getElementById("container");
          const viewer = document.getElementById("viewer");
          const footer = document.getElementById("footer");
          const dismiss = document.getElementById("dismiss");

          container.style.width = viewer.style.width = `${windowWidth}px`;
          container.style.height = `${windowHeight}px`;
          viewer.style.height = `${windowHeight - footerHeight}px`;
          footer.style.height = `${footerHeight}px`;
          footer.style.width = `${windowWidth - footerRight}px`;
          // window.addEventListener('resize', () => {}); // TODO

          rendition = book.renderTo(viewer, {
            width: "100%",
            height: "100%",
            allowPopups: true,
            allowScriptedContent: true,
          });

          let randomThemeName = Math.random().toString(36).substring(2, 15);
          if (
            window.matchMedia &&
            window.matchMedia("(prefers-color-scheme: dark)").matches
          ) {
            rendition.themes.register(randomThemeName, getDarkStyles());
            footer.style.backgroundColor = darkBackgroundColor;
            footer.style.color = darkForegroundColor;
            dismiss.style.color = darkLinkColor;
          } else {
            rendition.themes.register(randomThemeName, getLightStyles());
            footer.style.backgroundColor = lightBackgroundColor;
            footer.style.color = lightForegroundColor;
            dismiss.style.color = lightLinkColor;
          }
          rendition.themes.select(randomThemeName);

          window
            .matchMedia("(prefers-color-scheme: dark)")
            .addEventListener("change", (event) => {
              const newColorScheme = event.matches ? "dark" : "light";
              // TODO
            });

          if (initialProgress.length > 0) {
            rendition.display(initialProgress);
          } else {
            rendition.display();
          }

          let startX = 0;
          const handleTouchStart = (e) => {
            startX = e.changedTouches[0].screenX;
          };

          const handleTouchEnd = (e) => {
            const endX = e.changedTouches[0].screenX;
            const deltaX = endX - startX;
            const threshold = 50; // px threshold to count as swipe

            if (Math.abs(deltaX) > threshold) {
              if (deltaX < 0) {
                rendition.next();
              } else {
                rendition.prev();
              }
            } else {
              if (startX < window.innerWidth / 2) {
                rendition.prev();
              } else {
                rendition.next();
              }
            }
          };

          rendition.on("touchstart", handleTouchStart);
          rendition.on("touchend", handleTouchEnd);

          rendition.on("relocated", (location) => {
            const percentage = book.locations.percentageFromCfi(
              location.start.cfi,
            );
            if (percentage === undefined) {
              setPercentage(0);
            } else {
              setPercentage(Math.floor(percentage * 100));
            }
            window.webkit.messageHandlers.readerEvent.postMessage({
              type: "progress",
              cfi: location.start.cfi,
            });
            if (location.atEnd) {
              window.webkit.messageHandlers.readerEvent.postMessage({
                type: "at end",
              });
            }
          });
        } catch (e) {
          console.error(e);
        }
      }
    </script>
  </body>
</html>
